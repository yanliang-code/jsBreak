##### 作用域和闭包（chapter02\03作用域和闭包.html）

###### 一、题目

1. 说一下对变量提升的理解
   - 参考执行上下文知识点
2. 说明 this 几种不同的使用场景
   - 参考 this 知识点
3. 创建10个 a 标签，点击时弹出对应的序号
   - 参考 137 行
   - 如何理解作用域
   - 自由变量
   - 作用域链，即自由变量的查找（重点）
   - 闭包的两个场景
5. 实际开发中闭包的应用

###### 二、知识点

1. 执行上下文（10行）

   - 理解：
     
   - 在执行js代码前，将代码中的一些拿出，提前执行。
     
   - 范围：

     - 一段<script> （全局执行上下文）
       - 变量定义、函数声明（执行之前，将其拿出）
     - 一个函数（函数执行上下文）
       - 变量定义、函数声明、this、arguments（在函数执行之前，将其拿出）

   - 注意：

     - 函数声明

       - ```javascript
         function fn() {
             var b = 200;
         }
         ```

     - 函数表达式（函数表达式，函数不会再执行上下文时声明，会将其变量a提前声明，所以在其位置前调用此函数会报错）

       - ```javascript
         var a = function(){
             var b = 200;
         }
         ```

2. this（40行）

   - 理解：
     - this在执行时确认值，定义时无法确认
   - this情况
     - 作为构造函数执行
       - 会自动生成一个新对象，this执行此新对象，执行构造函数内代码，最终return this
     - 作为对象属性执行
       - this 指向作为调用者的对象
     - 作为普通函数执行
       - this 指向 window
     - call  apply  bind
       - call  apply  函数为调用者，第一个参数为this指向，其余call参数挨个传入，apply使用数组传入（58行）
       - bind  在声明定义函数时绑定this指向，调用该函数就按照普通函数执行即可（60行）
   
3. 作用域（64行）

   - 理解
     - var没有块级作用域
     - 只有全局和函数作用域

4. 作用域链（89行）

   - 理解
     - 定义函数就形成作用域链
     - 当前作用域没有定义的变量，即为自由变量，需要按照函数定义时形成的路径（作用域链），逐级向上，判断父级作用域是否声明此变量，直到window的作用域。如果在window中也找不到，就报错了
     - 函数a内定义了此函数，此函数的父级作用域就是函数a

5. 闭包（106行）

   - 使用场景
     - 函数作为返回值
     - 函数作为参数传递
   - 好处
     - 保护变量，私有化，只有函数内能获取修改（形式函数中套了一个函数，内层函数可以访问外层函数中的局部数据）
   - 缺点
     - 一直存在于内存中

6. 关于内存释放和作用域销毁的知识

   - 堆回收

     - 堆： 存放的时属性名和属性值或函数体的字符串；对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用地址，如果外面有变量指到了这个地址，那么这个内存就被占用了，不能销毁了。如果要销毁/释放堆内存，就让这个变量的值等于null。

   - 栈回收

     - 栈： 是js代码执行的环境。

       - 全局作用域下：当页面关闭的时候全局作用域才会销毁。

       - 私有作用域：一般情况下，函数执行还会形成一个新的私有作用域，当私有作用域中的代码执行完成后，当前作用域都会进行释放和销毁。

       - 特殊情况下，当私有作用域中的部分内存被作用域以外的东西占用了，那么当前的这个作用域就不能销毁了。这样的情况如下：

         - 函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的变量给接收了，这个情形下形成的作用域不会销毁（例如：闭包）

           - ```javascript
             function fn(){
                 var num = 10;
                 return function(){
                     num++;
                 }
             }
             var f = fn();
             ```

         - 在一个私有的作用域中给DOM元素的事件绑定方法，一般情况下都不能销毁（通过DOM方法获取的元素都是对象数据类型的值）

           - ```javascript
             var box = document.getElementById('box');
             ~function(){
                 var num = 10;
                 box.onclick = function(){
                     num++;
                     console.log(num)  //11
                 }
                 console.log(num)  // 10
             }()
             ```

         - 当函数内部返回的函数没有被其他的变量占用，但是还需要执行一次的时候，不立即销毁。

           - ```javascript
             function fn(){
                 var num = 10;
                 return function(){
                     num++;
                     console.log(num)
                 }
             }
             fn()();
             ```

             

           

           